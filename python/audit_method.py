from utility.utility import CachedMethod, beta_binomial_cdffrom math import ceil, logimport pandas as pdimport numpy as npfrom scipy.stats import normclass Bayesian:    name = "bayesian"    def __init__(self, a=1, b=1, thresh=0.95,  min_stop=False):        self.a = a        self.b = b        self.thresh = thresh        self.min_stop = min_stop            @CachedMethod    def __call__(self, n, t, y_t):        if self.min_stop is not False and t < self.min_stop:            return False        k = ceil(n/2 - y_t)        p_reject = 1 - beta_binomial_cdf(k, y_t+self.a, t-y_t+self.b, n-t)        return p_reject > self.thresh    def __str__(self):        return f"{self.name}_{self.thresh*100:05.2f}_{self.a:02}_{self.b:02}"# BRAVOclass BRAVO:    name = "bravo"    quantiles = pd.DataFrame(        [            [12, 22, 38, 60, 131, 30],            [23, 38, 66, 108, 236, 53],            [49, 84, 149, 244, 538, 119],            [77, 131, 231, 381, 840, 184],            [93, 332, 587, 974, 2157, 469],            [301, 518, 916, 1520, 3366, 730],            [531, 914, 1619, 2700, 5980, 1294],            [1188, 2051, 3637, 6053, 13455, 2900],            [4725, 8157, 14486, 24149, 53640, 11556],            [18839, 32547, 57838, 96411, 214491, 46126]        ],        index=[0.7, 0.65, 0.60, 0.58, 0.55, 0.54, 0.53, 0.52, 0.51, 0.505],        columns=[0.25, 0.5, 0.75, 0.9, 0.99, "mean"]    )    def __init__(self, p, alpha, p_0=0.5):        """        :param p: The assumed true share        :param alpha: The risk limit        :param p_0: p_0 used for null hypothesis (default to 0.5)        """        self.alpha = alpha        self.p = p                self.y_val = log(p/p_0)        self.not_y_val = log((1-p)/p_0)        self.thresh = log(1/alpha)    @CachedMethod    def __call__(self, n, t, y_t):        y = y_t        not_y = t - y                # log(p/0.5)^y        sum_y_val = self.y_val * y        # log((1-p)/0.5)^(t-y)        sum_not_y_val = self.not_y_val * not_y                # total log(p/0.5)^y + log((1-p)/0.5)^(t-y) = log()        sum_val = sum_y_val + sum_not_y_val        return sum_val >= self.thresh    def __str__(self):        return f"{self.name}_{self.alpha*100:04.1f}_{self.p*100:02.0f}"# BRAVOclass HyperGeomBRAVO:    name = "hyper_geom_bravo"    def __init__(self, p, alpha, p_0=0.5):        """        :param p: The assumed true share        :param alpha: The risk limit        :param p_0: p_0 used for null hypothesis (default to 0.5)        """        self.alpha = alpha        self.p = p        self.y_val = log(p/p_0)        self.not_y_val = log((1-p)/p_0)        self.thresh = log(1/alpha)    @CachedMethod    def __call__(self, n, t, y_t):        y = y_t        not_y = t - y        # log(p/0.5)^y        sum_y_val = self.y_val * y        # log((1-p)/0.5)^(t-y)        sum_not_y_val = self.not_y_val * not_y        # total log(p/0.5)^y + log((1-p)/0.5)^(t-y) = log()        sum_val = sum_y_val + sum_not_y_val        return sum_val >= self.thresh    def __str__(self):        return f"{self.name}_{self.alpha*100:04.1f}_{self.p*100:02.0f}"class Clip:    name = "clip"    betas = pd.DataFrame(        [            [2.683, 2.500, 2.236, 2.000, 1.732, 1.155],            [2.887, 2.694, 2.425, 2.145, 1.877, 1.343],            [3.054, 2.864, 2.546, 2.294, 2.000, 1.414],            [3.184, 3.000, 2.670, 2.401, 2.095, 1.511],            [3.290, 3.077, 2.770, 2.496, 2.183, 1.633],            [3.357, 3.144, 2.828, 2.556, 2.240, 1.715],            [3.411, 3.206, 2.889, 2.638, 2.324, 1.747],            [3.487, 3.273, 2.958, 2.684, 2.375, 1.817],            [3.530, 3.309, 3.000, 2.734, 2.438, 1.890],            [3.560, 3.352, 3.040, 2.782, 2.474, 1.937]        ],        columns=[0.01, 0.02, 0.05, 0.1, 0.2, 0.5],        index=[100, 300, 1000, 3000, 10000, 30000, 100000, 300000,               1000000, 3000000])    @staticmethod    def _compute_beta(n, alpha, conservative=True):        """        Approximate compute beta based on values        """        if conservative:            const = 1        else:            const = 0.86        return 0.075 * np.log(n) + 0.7 * norm.isf(alpha) + const    def __init__(self, n, alpha, conservative=True):        self.n = n        self.alpha = alpha        if n in self.betas.index and alpha in self.betas.columns:            self.beta = self.betas.loc[n, alpha]        else:            self.beta = self._compute_beta(n, alpha, conservative)            @CachedMethod    def __call__(self, n, t, y_t):        a = y_t        b = t - y_t        return (a - b) > self.beta * np.sqrt(t)    def __str__(self):        return f"{self.name}_{self.n:06}_{self.alpha*100:04.1f}"if __name__ == "__main__":    # verify clip compute    # for n in Clip.betas.index:    #     for alpha in Clip.betas.columns:    #         beta = Clip.betas.loc[n, alpha]    #         compute_beta = Clip._compute_beta(n, alpha)    #         if abs(beta - compute_beta) > 1e-3:    #             print(f"Warning: beta = {beta}, "    #                   f"compute_beta = {compute_beta}")    pass